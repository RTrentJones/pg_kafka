name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Cancel in-progress runs when a new commit is pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  PGRX_VERSION: "0.16.1"
  PG_VERSION: "14.20"

permissions:
  contents: read
  pull-requests: write

jobs:
  # Quick checks that run in parallel with the main test suite
  lint:
    name: Lint & Format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: nightly
          components: rustfmt, clippy

      - name: Check formatting
        run: cargo fmt -- --check

      # pgrx setup required for clippy (pgrx-pg-sys needs PostgreSQL headers)
      - name: Install System Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libpq-dev libreadline-dev zlib1g-dev flex bison libxml2-dev libxslt-dev libssl-dev libsasl2-dev libzstd-dev

      - name: Cache cargo-pgrx binary
        id: cache-cargo-pgrx
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/cargo-pgrx
          key: ${{ runner.os }}-cargo-pgrx-bin-${{ env.PGRX_VERSION }}

      - name: Install pgrx
        if: steps.cache-cargo-pgrx.outputs.cache-hit != 'true'
        run: cargo install --locked cargo-pgrx --version ${{ env.PGRX_VERSION }}

      - name: Cache pgrx PostgreSQL Binaries
        id: cache-pgrx
        uses: actions/cache@v4
        with:
          path: |
            ~/.pgrx/14.*
            ~/.pgrx/14.*_unpack
            ~/.pgrx/config.toml
          key: ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-pg${{ env.PG_VERSION }}-v2
          restore-keys: |
            ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-

      - name: Initialize pgrx
        if: steps.cache-pgrx.outputs.cache-hit != 'true'
        run: cargo pgrx init --pg14 download

      - name: Run clippy
        run: cargo clippy --features pg14 -- -D warnings

  test:
    name: Test Suite
    runs-on: ubuntu-latest
    needs: lint  # Only run tests if lint passes

    steps:
    # ------------------------------------------------------------------
    # CLEAN SETUP: Prepare the runner environment
    # ------------------------------------------------------------------
    - name: Checkout code
      uses: actions/checkout@v4
      # Fetches pg_kafka code so the runner can access it.

    - name: Free disk space
      # pgrx builds are large (~1-2GB) and can exhaust runner disk space
      # Remove unused preinstalled software to free ~10GB
      run: |
        echo "Disk space before cleanup:"
        df -h /
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /opt/ghc
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf /usr/local/lib/android
        sudo apt-get clean
        echo "Disk space after cleanup:"
        df -h /

    - name: Install Rust toolchain
      uses: actions-rust-lang/setup-rust-toolchain@v1
      with:
        toolchain: nightly
        # 'rustfmt' for style checks, 'clippy' for linting
        components: rustfmt, clippy, llvm-tools-preview

    # Install system deps BEFORE Rust Cache so librdkafka builds with zstd support
    - name: Install System Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libpq-dev libreadline-dev zlib1g-dev flex bison libxml2-dev libxslt-dev libssl-dev libsasl2-dev libzstd-dev netcat-openbsd

    - name: Rust Cache
      uses: Swatinem/rust-cache@v2
      with:
        # Cache version - bump when system dependencies change (e.g., adding libzstd-dev)
        prefix-key: v2
        # cache the main workspace AND the kafka_test crate
        workspaces: |
          . -> target
          kafka_test -> kafka_test/target
      # intelligently caches Rust dependencies to speed up builds significantly.

    # ------------------------------------------------------------------
    # OPTIMIZATION: Cache the CLI tool to avoid compiling it every run
    # ------------------------------------------------------------------
    - name: Cache cargo-pgrx binary
      id: cache-cargo-pgrx
      uses: actions/cache@v4
      with:
        path: ~/.cargo/bin/cargo-pgrx
        # Cache key includes runner OS and version, but NOT Cargo.lock
        key: ${{ runner.os }}-cargo-pgrx-bin-${{ env.PGRX_VERSION }}

    - name: Install pgrx
      if: steps.cache-cargo-pgrx.outputs.cache-hit != 'true'
      # Installs the pgrx CLI tool which we use to manage the Postgres lifecycle
      run: cargo install --locked cargo-pgrx --version ${{ env.PGRX_VERSION }}

    # ------------------------------------------------------------------
    # OPTIMIZATION: Cache Postgres binaries (~/.pgrx)
    # CRITICAL: Only cache the compiled binaries, NOT runtime files
    # ------------------------------------------------------------------
    - name: Cache pgrx PostgreSQL Binaries
      id: cache-pgrx
      uses: actions/cache@v4
      with:
        path: |
          ~/.pgrx/14.*
          ~/.pgrx/14.*_unpack
          ~/.pgrx/config.toml
        # Stable key - only invalidate when pgrx or PG version changes
        key: ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-pg${{ env.PG_VERSION }}-v2
        restore-keys: |
          ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-

    - name: Initialize pgrx
      if: steps.cache-pgrx.outputs.cache-hit != 'true'
      # Downloads and compiles PostgreSQL 14 (~25 minutes on cold cache)
      run: cargo pgrx init --pg14 download

    # ------------------------------------------------------------------
    # UNIT TESTING: Non-SPI tests only
    # ------------------------------------------------------------------
    - name: Install cargo-llvm-cov
      uses: taiki-e/install-action@cargo-llvm-cov

    - name: Run unit tests and generate coverage
      # Note: We skip 'cargo pgrx test' because pg_kafka uses PGC_POSTMASTER GUCs
      # which require shared_preload_libraries BEFORE Postgres starts.
      # cargo pgrx test creates the extension AFTER starting Postgres, causing:
      # "FATAL: cannot create PGC_POSTMASTER variables after startup"
      #
      # Instead, we run non-SPI unit tests here (protocol, encoding, helpers).
      # SPI/integration tests are in kafka_test/ E2E suite below.
      run: cargo llvm-cov --lib --features pg14 --lcov --output-path lcov.info
      env:
        # Override RUSTFLAGS to avoid -D warnings (pgrx macros cause false positives)
        RUSTFLAGS: ""

    - name: Upload to Codecov
      uses: codecov/codecov-action@v5
      with:
        files: lcov.info
        token: ${{ secrets.CODECOV_TOKEN }}
        fail_ci_if_error: true  # Fail CI if coverage drops below threshold

    # ------------------------------------------------------------------
    # E2E TESTING: Full system test with external client
    # ------------------------------------------------------------------
    - name: Install Extension
      # Compiles the release build of the pg_kafka extension and copies the .so and .control
      # files into the pgrx-managed Postgres installation directories.
      run: |
        # Debug: List pgrx directory contents
        echo "Contents of ~/.pgrx:"
        ls -la ~/.pgrx/

        # Find pg_config in the pgrx directory structure
        PG_CONFIG=$(find ~/.pgrx -name pg_config -type f -executable 2>/dev/null | grep "14\." | head -n 1)

        if [ -z "$PG_CONFIG" ]; then
          echo "Error: Could not find pg_config for PostgreSQL 14."
          echo "Searching for any pg_config files:"
          find ~/.pgrx -name pg_config -type f
          exit 1
        fi

        echo "Found pg_config at: $PG_CONFIG"

        # Verify it works
        $PG_CONFIG --version

        # Add to PATH and install
        export PATH="$(dirname $PG_CONFIG):$PATH"
        cargo pgrx install --release --pg-config="$PG_CONFIG"

    - name: Initialize Postgres Data Directory
      # pgrx creates the data directory on first start, so we do a quick start/stop
      # to ensure it exists before we modify the config
      run: |
        # Start postgres to create the data directory
        cargo pgrx start pg14 || true
        sleep 2
        # Stop it so we can modify the config
        cargo pgrx stop pg14 || true
        sleep 1

    - name: Configure Postgres for Background Worker
      # CRITICAL STEP:
      # The pg_kafka background worker requires 'BgWorkerStartTime::PostmasterStart'.
      # For this to work, the library must be loaded when Postgres boots up.
      # We append it to shared_preload_libraries in the config file.
      run: |
        # Find the pgrx data directory (should exist now after initialization)
        PG14_DATA_DIR=$(find ~/.pgrx -maxdepth 1 -type d -name "data-14*" | head -n 1)
        if [ -z "$PG14_DATA_DIR" ]; then
          echo "Error: Could not find pgrx-managed Postgres 14 data directory."
          ls -la ~/.pgrx/
          exit 1
        fi
        echo "Using Postgres data directory at: $PG14_DATA_DIR"

        # Check if already configured (idempotency)
        if ! grep -q "shared_preload_libraries.*pg_kafka" "$PG14_DATA_DIR/postgresql.conf"; then
          # Use printf to ensure a preceding newline, preventing config corruption
          printf "\nshared_preload_libraries = 'pg_kafka'\npg_kafka.host = '0.0.0.0'\n" >> "$PG14_DATA_DIR/postgresql.conf"
          echo "Configuration updated to preload pg_kafka."
        else
          echo "pg_kafka already configured in shared_preload_libraries."
        fi

    - name: Start Postgres
      # Boots the pgrx-managed Postgres 14 instance.
      # Because we configured shared_preload_libraries above, the background worker will start now.
      run: cargo pgrx start pg14

    - name: Create Extension and Prepare DB
      run: |
        # 1. Find the pgrx data directory and dynamic port
        PG14_DATA_DIR=$(find ~/.pgrx -maxdepth 1 -type d -name "data-14*" | head -n 1)
        if [ -z "$PG14_DATA_DIR" ]; then
          echo "Error: Could not find pgrx-managed Postgres 14 data directory."
          exit 1
        fi
        PG_PORT=$(grep "port =" "$PG14_DATA_DIR/postgresql.conf" | awk '{print $3}')
        echo "PG_PORT=$PG_PORT" >> $GITHUB_ENV

        # 2. Run CREATE EXTENSION in the postgres database
        # IMPORTANT: The background worker connects to 'postgres' database via SPI,
        # so the extension (and its schema) must be created there.
        DB_USER=$(whoami)
        echo "DB_USER=$DB_USER" >> $GITHUB_ENV
        echo "Using database user: $DB_USER"
        psql -h localhost -p $PG_PORT -U "$DB_USER" -d postgres -c "CREATE EXTENSION IF NOT EXISTS pg_kafka;"

    - name: Wait for Kafka Port
      # Ensure the background worker has actually bound to the port before testing
      timeout-minutes: 1
      run: |
        echo "Waiting for port 9092..."
        timeout 30s bash -c 'until nc -z 127.0.0.1 9092; do sleep 1; done'
        echo "Port 9092 is open!"
        sleep 3 # Wait for protocol readiness (Fixes CI race condition)

    - name: Run Functional E2E Tests
      # Runs functional tests (excludes performance and shadow tests which run separately)
      timeout-minutes: 10
      run: |
        cd kafka_test
        cargo run --release -- --exclude performance --exclude shadow
      env:
        # Pass the dynamically discovered port to the test runner
        # IMPORTANT: Use 'postgres' database since that's where the worker connects via SPI
        DATABASE_URL: postgresql://${{ env.DB_USER }}@localhost:${{ env.PG_PORT }}/postgres

    - name: Run Shadow Mode E2E Tests
      # Shadow mode tests run separately to isolate external Kafka interactions
      # These are advisory - don't block CI while shadow mode is being developed
      timeout-minutes: 5
      continue-on-error: true
      run: |
        cd kafka_test
        cargo run --release -- --category shadow
      env:
        DATABASE_URL: postgresql://${{ env.DB_USER }}@localhost:${{ env.PG_PORT }}/postgres

    - name: Run Performance E2E Tests
      # Performance tests run separately with their own timeout
      # These are advisory - don't block CI on performance regressions
      timeout-minutes: 5
      continue-on-error: true
      run: |
        cd kafka_test
        cargo run --release -- --category performance
      env:
        DATABASE_URL: postgresql://${{ env.DB_USER }}@localhost:${{ env.PG_PORT }}/postgres

    - name: Dump Postgres Logs (On Failure)
      if: failure()
      run: |
        echo "=== Postgres Logs ==="
        find ~/.pgrx -name "14.log" -exec cat {} + 2>/dev/null || \
        find ~/.pgrx -name "logfile" -exec tail -100 {} + 2>/dev/null || \
        echo "No log files found"
        echo ""
        echo "=== Port 9092 Status ==="
        ss -tlnp | grep 9092 || echo "Port 9092 not listening"

    # ------------------------------------------------------------------
    # TEARDOWN: Cleanup
    # ------------------------------------------------------------------
    - name: Stop pgrx
      if: always()
      # Ensures the background Postgres process is killed, freeing resources.
      run: cargo pgrx stop pg14

  # Security audit for known vulnerabilities
  security:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
      - name: Install cargo-audit
        run: cargo install cargo-audit --locked
      - name: Run security audit
        run: cargo audit
        continue-on-error: true  # Advisory - don't fail CI for now

  # Verify Cargo.lock is up-to-date
  lockfile:
    name: Verify Lockfile
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: nightly

      # pgrx setup required for cargo check (pgrx-pg-sys needs PostgreSQL headers)
      - name: Install System Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libpq-dev libreadline-dev zlib1g-dev flex bison libxml2-dev libxslt-dev libssl-dev libsasl2-dev libzstd-dev

      - name: Cache cargo-pgrx binary
        id: cache-cargo-pgrx
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/cargo-pgrx
          key: ${{ runner.os }}-cargo-pgrx-bin-${{ env.PGRX_VERSION }}

      - name: Install pgrx
        if: steps.cache-cargo-pgrx.outputs.cache-hit != 'true'
        run: cargo install --locked cargo-pgrx --version ${{ env.PGRX_VERSION }}

      - name: Cache pgrx PostgreSQL Binaries
        id: cache-pgrx
        uses: actions/cache@v4
        with:
          path: |
            ~/.pgrx/14.*
            ~/.pgrx/14.*_unpack
            ~/.pgrx/config.toml
          key: ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-pg${{ env.PG_VERSION }}-v2
          restore-keys: |
            ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-

      - name: Initialize pgrx
        if: steps.cache-pgrx.outputs.cache-hit != 'true'
        run: cargo pgrx init --pg14 download

      - name: Check Cargo.lock is up-to-date
        # Use cargo check --locked to verify lockfile matches Cargo.toml
        # This will fail if Cargo.lock needs updating
        run: cargo check --locked --features pg14