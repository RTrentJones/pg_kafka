name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

permissions:
  contents: read
  pull-requests: write

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest

    steps:
    # ------------------------------------------------------------------
    # CLEAN SETUP: Prepare the runner environment
    # ------------------------------------------------------------------
    - name: Checkout code
      uses: actions/checkout@v4
      # Fetches pg_kafka code so the runner can access it.

    - name: Install Rust toolchain
      uses: actions-rust-lang/setup-rust-toolchain@v1
      with:
        toolchain: nightly
        # 'rustfmt' for style checks, 'clippy' for linting
        components: rustfmt, clippy

    - name: Rust Cache
      uses: Swatinem/rust-cache@v2
      # intelligently caches Rust dependencies to speed up builds significantly.

    - name: Install System Dependencies
      run: |
        sudo apt-get update
        # libpq-dev is required to link against Postgres libraries
        # libreadline-dev, zlib1g-dev, etc. are required for compiling Postgres from source
        sudo apt-get install -y libpq-dev libreadline-dev zlib1g-dev flex bison libxml2-dev libxslt-dev

    # ------------------------------------------------------------------
    # OPTIMIZATION: Cache the CLI tool to avoid compiling it every run
    # ------------------------------------------------------------------
    - name: Cache cargo-pgrx binary
      id: cache-cargo-pgrx
      uses: actions/cache@v4
      with:
        path: ~/.cargo/bin/cargo-pgrx
        # Cache key includes runner OS and version, but NOT Cargo.lock
        key: ${{ runner.os }}-cargo-pgrx-bin-0.16.1

    - name: Install pgrx
      if: steps.cache-cargo-pgrx.outputs.cache-hit != 'true'
      # Installs the pgrx CLI tool which we use to manage the Postgres lifecycle
      run: cargo install --locked cargo-pgrx --version 0.16.1

    # ------------------------------------------------------------------
    # OPTIMIZATION: Cache Postgres binaries (~/.pgrx)
    # CRITICAL: Only cache the compiled binaries, NOT runtime files
    # ------------------------------------------------------------------
    - name: Cache pgrx PostgreSQL Binaries
      id: cache-pgrx
      uses: actions/cache@v4
      with:
        path: |
          ~/.pgrx/14.20
          ~/.pgrx/14.20_unpack
          ~/.pgrx/config.toml
        # Stable key - only invalidate when pgrx or PG version changes
        key: ${{ runner.os }}-pgrx-pg14-0.16.1-pg14.20-v2
        restore-keys: |
          ${{ runner.os }}-pgrx-pg14-0.16.1-

    - name: Initialize pgrx
      if: steps.cache-pgrx.outputs.cache-hit != 'true'
      # Downloads and compiles PostgreSQL 14 (~25 minutes on cold cache)
      run: cargo pgrx init

    - name: Verify pgrx Installation
      run: |
        ls -lh ~/.pgrx/
        echo "pgrx PostgreSQL 14 installation: $(du -sh ~/.pgrx/14.20 | cut -f1)"

    # ------------------------------------------------------------------
    # LINTING: Static analysis
    # ------------------------------------------------------------------
    - name: Check formatting
      # Ensures code follows standard Rust style guidelines
      run: cargo fmt -- --check

    - name: Run clippy
      # Catches common mistakes and improves code quality.
      # We enable 'pg14' feature so it checks code conditionally compiled for PG14.
      run: cargo clippy --features pg14 -- -D warnings

    # ------------------------------------------------------------------
    # UNIT & INTEGRATION TESTING: Internal Rust/SPI tests
    # ------------------------------------------------------------------
    - name: Run unit and integration tests
      # 'cargo pgrx test' spins up a temporary, managed Postgres instance,
      # installs the extension, and runs functions marked with #[pg_test].
      # This tests internal logic and SPI (database) interactions.
      run: cargo pgrx test pg14

    # ------------------------------------------------------------------
    # E2E TESTING: Full system test with external client
    # ------------------------------------------------------------------
    - name: Install Extension
      # Compiles the release build of the pg_kafka extension and copies the .so and .control
      # files into the pgrx-managed Postgres installation directories.
      run: cargo pgrx install --pg14 --release

    - name: Configure Postgres for Background Worker
      # CRITICAL STEP:
      # The pg_kafka background worker requires 'BgWorkerStartTime::PostmasterStart'.
      # For this to work, the library must be loaded when Postgres boots up.
      # We append it to shared_preload_libraries in the config file.
      run: |
        echo "shared_preload_libraries = 'pg_kafka'" >> ~/.pgrx/data-14/postgresql.conf
        echo "Configuration updated to preload pg_kafka."

    - name: Start Postgres
      # Boots the pgrx-managed Postgres 14 instance.
      # Because we configured shared_preload_libraries above, the background worker will start now.
      run: cargo pgrx start pg14

    - name: Create Extension and Prepare DB
      run: |
        # 1. Find the dynamic port pgrx assigned to PG14
        PG_PORT=$(grep "port =" ~/.pgrx/data-14/postgresql.conf | awk '{print $3}')
        echo "PG_PORT=$PG_PORT" >> $GITHUB_ENV

        # 2. Run CREATE EXTENSION
        # Even though the binary is loaded, we must run this SQL to create the
        # SQL-level objects (tables, types, etc.) in the database.
        psql -h localhost -p $PG_PORT -U postgres postgres -c "CREATE EXTENSION IF NOT EXISTS pg_kafka;"

    - name: Run E2E Tests
      # Runs the external client application that connects to the running extension
      # via TCP (Kafka protocol) and Postgres (SQL).
      run: |
        cd kafka_test
        cargo run --release
      env:
        # Pass the dynamically discovered port to the test runner
        DATABASE_URL: postgresql://postgres:postgres@localhost:${{ env.PG_PORT }}/postgres

    # ------------------------------------------------------------------
    # LOAD TESTING: Placeholder
    # ------------------------------------------------------------------
    - name: Load Testing (Placeholder)
      if: always() # Run even if previous tests failed, to gather metrics if possible
      run: |
        echo "TODO: Implement Load Testing"
        # Example: Run k6 or bespoke load generator
        # k6 run load-test.js
        # cargo run --release --bin load_generator

    # ------------------------------------------------------------------
    # TEARDOWN: Cleanup
    # ------------------------------------------------------------------
    - name: Stop pgrx
      if: always()
      # Ensures the background Postgres process is killed, freeing resources.
      run: cargo pgrx stop pg14
      # PERMISSIONS: Required for the AI reviewer to post comments on PRs

  # ------------------------------------------------------------------
  # AI REVIEWER: Automated Code Review via Gemini
  # ------------------------------------------------------------------
  ai-review:
    name: AI Code Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Gemini Review
        uses: google-github-actions/run-gemini-cli@v1
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          prompt: "Review this pull request. Focus on Rust safety, correct usage of pgrx, and PostgreSQL extension best practices. Identify potential bugs, security issues, and performance bottlenecks."
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}