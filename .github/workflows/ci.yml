name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest

    steps:
    # ------------------------------------------------------------------
    # CLEAN SETUP: Prepare the runner environment
    # ------------------------------------------------------------------
    - name: Checkout code
      uses: actions/checkout@v4
      # Fetches pg_kafka code so the runner can access it.

    - name: Install Rust toolchain
      uses: actions-rust-lang/setup-rust-toolchain@v1
      with:
        toolchain: nightly
        # 'rustfmt' for style checks, 'clippy' for linting
        components: rustfmt, clippy

    - name: Rust Cache
      uses: Swatinem/rust-cache@v2
      # intelligently caches Rust dependencies to speed up builds significantly.

    - name: Install System Dependencies
      run: |
        sudo apt-get update
        # libpq-dev is required to link against Postgres libraries
        sudo apt-get install -y libpq-dev libreadline-dev zlib1g-dev flex bison libxml2-dev libxslt-dev

    - name: Install pgrx
      # Installs the pgrx CLI tool which we use to manage the Postgres lifecycle
      run: cargo install --locked cargo-pgrx --version 0.16.1

    - name: Cache pgrx home
      id: cache-pgrx
      uses: actions/cache@v4
      # Caches the compiled Postgres binaries (~200MB) so we don't download/compile PG every run
      with:
        path: ~/.pgrx
        key: ${{ runner.os }}-pgrx-0.16.1-${{ hashFiles('**/Cargo.lock') }}

    - name: Initialize pgrx
      if: steps.cache-pgrx.outputs.cache-hit != 'true'
      # Downloads and compiles PostgreSQL 14 if not found in cache
      run: cargo pgrx init

    # ------------------------------------------------------------------
    # LINTING: Static analysis
    # ------------------------------------------------------------------
    - name: Check formatting
      # Ensures code follows standard Rust style guidelines
      run: cargo fmt -- --check

    - name: Run clippy
      # Catches common mistakes and improves code quality.
      # We enable 'pg14' feature so it checks code conditionally compiled for PG14.
      run: cargo clippy --features pg14 -- -D warnings

    # ------------------------------------------------------------------
    # UNIT & INTEGRATION TESTING: Internal Rust/SPI tests
    # ------------------------------------------------------------------
    - name: Run unit and integration tests
      # 'cargo pgrx test' spins up a temporary, managed Postgres instance,
      # installs the extension, and runs functions marked with #[pg_test].
      # This tests internal logic and SPI (database) interactions.
      run: cargo pgrx test pg14

    # ------------------------------------------------------------------
    # E2E TESTING: Full system test with external client
    # ------------------------------------------------------------------
    - name: Install Extension
      # Compiles the release build of the pg_kafka extension and copies the .so and .control
      # files into the pgrx-managed Postgres installation directories.
      run: cargo pgrx install --pg14 --release

    - name: Configure Postgres for Background Worker
      # CRITICAL STEP:
      # The pg_kafka background worker requires 'BgWorkerStartTime::PostmasterStart'.
      # For this to work, the library must be loaded when Postgres boots up.
      # We append it to shared_preload_libraries in the config file.
      run: |
        echo "shared_preload_libraries = 'pg_kafka'" >> ~/.pgrx/data-14/postgresql.conf
        echo "Configuration updated to preload pg_kafka."

    - name: Start Postgres
      # Boots the pgrx-managed Postgres 14 instance.
      # Because we configured shared_preload_libraries above, the background worker will start now.
      run: cargo pgrx start pg14

    - name: Create Extension and Prepare DB
      run: |
        # 1. Find the dynamic port pgrx assigned to PG14
        PG_PORT=$(grep "port =" ~/.pgrx/data-14/postgresql.conf | awk '{print $3}')
        echo "PG_PORT=$PG_PORT" >> $GITHUB_ENV

        # 2. Run CREATE EXTENSION
        # Even though the binary is loaded, we must run this SQL to create the
        # SQL-level objects (tables, types, etc.) in the database.
        psql -h localhost -p $PG_PORT -U postgres postgres -c "CREATE EXTENSION IF NOT EXISTS pg_kafka;"

    - name: Run E2E Tests
      # Runs the external client application that connects to the running extension
      # via TCP (Kafka protocol) and Postgres (SQL).
      run: |
        cd kafka_test
        cargo run --release
      env:
        # Pass the dynamically discovered port to the test runner
        DATABASE_URL: postgresql://postgres:postgres@localhost:${{ env.PG_PORT }}/postgres

    # ------------------------------------------------------------------
    # LOAD TESTING: Placeholder
    # ------------------------------------------------------------------
    - name: Load Testing (Placeholder)
      if: always() # Run even if previous tests failed, to gather metrics if possible
      run: |
        echo "TODO: Implement Load Testing"
        # Example: Run k6 or bespoke load generator
        # k6 run load-test.js
        # cargo run --release --bin load_generator

    # ------------------------------------------------------------------
    # TEARDOWN: Cleanup
    # ------------------------------------------------------------------
    - name: Stop pgrx
      if: always()
      # Ensures the background Postgres process is killed, freeing resources.
      run: cargo pgrx stop pg14