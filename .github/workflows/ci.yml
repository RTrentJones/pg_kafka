name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  PGRX_VERSION: "0.16.1"
  PG_VERSION: "14.20"

permissions:
  contents: read
  pull-requests: write

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest

    steps:
    # ------------------------------------------------------------------
    # CLEAN SETUP: Prepare the runner environment
    # ------------------------------------------------------------------
    - name: Checkout code
      uses: actions/checkout@v4
      # Fetches pg_kafka code so the runner can access it.

    - name: Install Rust toolchain
      uses: actions-rust-lang/setup-rust-toolchain@v1
      with:
        toolchain: nightly
        # 'rustfmt' for style checks, 'clippy' for linting
        components: rustfmt, clippy, llvm-tools-preview

    - name: Rust Cache
      uses: Swatinem/rust-cache@v2
      with:
        # cache the main workspace AND the kafka_test crate
        workspaces: |
          . -> target
          kafka_test -> kafka_test/target
      # intelligently caches Rust dependencies to speed up builds significantly.

    - name: Install System Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libpq-dev libreadline-dev zlib1g-dev flex bison libxml2-dev libxslt-dev

    # ------------------------------------------------------------------
    # OPTIMIZATION: Cache the CLI tool to avoid compiling it every run
    # ------------------------------------------------------------------
    - name: Cache cargo-pgrx binary
      id: cache-cargo-pgrx
      uses: actions/cache@v4
      with:
        path: ~/.cargo/bin/cargo-pgrx
        # Cache key includes runner OS and version, but NOT Cargo.lock
        key: ${{ runner.os }}-cargo-pgrx-bin-${{ env.PGRX_VERSION }}

    - name: Install pgrx
      if: steps.cache-cargo-pgrx.outputs.cache-hit != 'true'
      # Installs the pgrx CLI tool which we use to manage the Postgres lifecycle
      run: cargo install --locked cargo-pgrx --version ${{ env.PGRX_VERSION }}

    # ------------------------------------------------------------------
    # OPTIMIZATION: Cache Postgres binaries (~/.pgrx)
    # CRITICAL: Only cache the compiled binaries, NOT runtime files
    # ------------------------------------------------------------------
    - name: Cache pgrx PostgreSQL Binaries
      id: cache-pgrx
      uses: actions/cache@v4
      with:
        path: |
          ~/.pgrx/${{ env.PG_VERSION }}
          ~/.pgrx/${{ env.PG_VERSION }}_unpack
          ~/.pgrx/config.toml
        # Stable key - only invalidate when pgrx or PG version changes
        key: ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-pg${{ env.PG_VERSION }}-v2
        restore-keys: |
          ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-

    - name: Initialize pgrx
      if: steps.cache-pgrx.outputs.cache-hit != 'true'
      # Downloads and compiles PostgreSQL 14 (~25 minutes on cold cache)
      run: cargo pgrx init --pg14 download

    # ------------------------------------------------------------------
    # LINTING: Fast checks first (fail fast)
    # ------------------------------------------------------------------
    - name: Check formatting
      run: cargo fmt -- --check

    - name: Run clippy
      run: cargo clippy --features pg14 -- -D warnings

    # ------------------------------------------------------------------
    # PGRX SETUP: Only after linting passes
    # ------------------------------------------------------------------
    - name: Verify pgrx Installation
      run: |
        ls -lh ~/.pgrx/
        echo "pgrx PostgreSQL 14 installation: $(du -sh ~/.pgrx/${{ env.PG_VERSION }} | cut -f1)"

    # ------------------------------------------------------------------
    # UNIT TESTING: Non-SPI tests only
    # ------------------------------------------------------------------
    - name: Install cargo-llvm-cov
      uses: taiki-e/install-action@cargo-llvm-cov

    - name: Run unit tests and generate coverage
      # Note: We skip 'cargo pgrx test' because pg_kafka uses PGC_POSTMASTER GUCs
      # which require shared_preload_libraries BEFORE Postgres starts.
      # cargo pgrx test creates the extension AFTER starting Postgres, causing:
      # "FATAL: cannot create PGC_POSTMASTER variables after startup"
      #
      # Instead, we run non-SPI unit tests here (protocol, encoding, helpers).
      # SPI/integration tests are in kafka_test/ E2E suite below.
      run: cargo llvm-cov --lib --features pg14 --lcov --output-path lcov.info
      env:
        # Override RUSTFLAGS to avoid -D warnings (pgrx macros cause false positives)
        RUSTFLAGS: ""

    - name: Upload to Codecov
      uses: codecov/codecov-action@v5
      with:
        files: lcov.info
        token: ${{ secrets.CODECOV_TOKEN }}
        fail_ci_if_error: true

    # ------------------------------------------------------------------
    # E2E TESTING: Full system test with external client
    # ------------------------------------------------------------------
    - name: Install Extension
      # Compiles the release build of the pg_kafka extension and copies the .so and .control
      # files into the pgrx-managed Postgres installation directories.
      run: cargo pgrx install --pg14 --release

    - name: Configure Postgres for Background Worker
      # CRITICAL STEP:
      # The pg_kafka background worker requires 'BgWorkerStartTime::PostmasterStart'.
      # For this to work, the library must be loaded when Postgres boots up.
      # We append it to shared_preload_libraries in the config file.
      run: |
        echo "shared_preload_libraries = 'pg_kafka'" >> ~/.pgrx/data-14/postgresql.conf
        echo "Configuration updated to preload pg_kafka."

    - name: Start Postgres
      # Boots the pgrx-managed Postgres 14 instance.
      # Because we configured shared_preload_libraries above, the background worker will start now.
      run: cargo pgrx start pg14

    - name: Create Extension and Prepare DB
      run: |
        # 1. Find the dynamic port pgrx assigned to PG14
        PG_PORT=$(grep "port =" ~/.pgrx/data-14/postgresql.conf | awk '{print $3}')
        echo "PG_PORT=$PG_PORT" >> $GITHUB_ENV

        # 2. Run CREATE EXTENSION
        # Even though the binary is loaded, we must run this SQL to create the
        # SQL-level objects (tables, types, etc.) in the database.
        psql -h localhost -p $PG_PORT -U postgres postgres -c "CREATE EXTENSION IF NOT EXISTS pg_kafka;"

    - name: Run E2E Tests
      # Runs the external client application that connects to the running extension
      # via TCP (Kafka protocol) and Postgres (SQL).
      run: |
        cd kafka_test
        cargo run --release
      env:
        # Pass the dynamically discovered port to the test runner
        DATABASE_URL: postgresql://postgres:postgres@localhost:${{ env.PG_PORT }}/postgres

    # ------------------------------------------------------------------
    # LOAD TESTING: Placeholder
    # ------------------------------------------------------------------
    - name: Load Testing (Placeholder)
      if: always() # Run even if previous tests failed, to gather metrics if possible
      run: |
        echo "TODO: Implement Load Testing"
        # Example: Run k6 or bespoke load generator
        # k6 run load-test.js
        # cargo run --release --bin load_generator

    # ------------------------------------------------------------------
    # TEARDOWN: Cleanup
    # ------------------------------------------------------------------
    - name: Stop pgrx
      if: always()
      # Ensures the background Postgres process is killed, freeing resources.
      run: cargo pgrx stop pg14

  # ------------------------------------------------------------------
  # AI REVIEWER: Automated Code Review via Gemini
  # ------------------------------------------------------------------
  ai-review:
    name: AI Code Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Gemini Review
        uses: google-github-actions/run-gemini-cli@v1
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          prompt: "Review this pull request. Focus on Rust safety, correct usage of pgrx, and PostgreSQL extension best practices. Identify potential bugs, security issues, and performance bottlenecks."
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}