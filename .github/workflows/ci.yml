name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  PGRX_VERSION: "0.16.1"
  PG_VERSION: "14.20"

permissions:
  contents: read
  pull-requests: write

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest

    steps:
    # ------------------------------------------------------------------
    # CLEAN SETUP: Prepare the runner environment
    # ------------------------------------------------------------------
    - name: Checkout code
      uses: actions/checkout@v4
      # Fetches pg_kafka code so the runner can access it.

    - name: Install Rust toolchain
      uses: actions-rust-lang/setup-rust-toolchain@v1
      with:
        toolchain: nightly
        # 'rustfmt' for style checks, 'clippy' for linting
        components: rustfmt, clippy, llvm-tools-preview

    - name: Rust Cache
      uses: Swatinem/rust-cache@v2
      with:
        # cache the main workspace AND the kafka_test crate
        workspaces: |
          . -> target
          kafka_test -> kafka_test/target
      # intelligently caches Rust dependencies to speed up builds significantly.

    - name: Install System Dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libpq-dev libreadline-dev zlib1g-dev flex bison libxml2-dev libxslt-dev libssl-dev libsasl2-dev

    # ------------------------------------------------------------------
    # OPTIMIZATION: Cache the CLI tool to avoid compiling it every run
    # ------------------------------------------------------------------
    - name: Cache cargo-pgrx binary
      id: cache-cargo-pgrx
      uses: actions/cache@v4
      with:
        path: ~/.cargo/bin/cargo-pgrx
        # Cache key includes runner OS and version, but NOT Cargo.lock
        key: ${{ runner.os }}-cargo-pgrx-bin-${{ env.PGRX_VERSION }}

    - name: Install pgrx
      if: steps.cache-cargo-pgrx.outputs.cache-hit != 'true'
      # Installs the pgrx CLI tool which we use to manage the Postgres lifecycle
      run: cargo install --locked cargo-pgrx --version ${{ env.PGRX_VERSION }}

    # ------------------------------------------------------------------
    # OPTIMIZATION: Cache Postgres binaries (~/.pgrx)
    # CRITICAL: Only cache the compiled binaries, NOT runtime files
    # ------------------------------------------------------------------
    - name: Cache pgrx PostgreSQL Binaries
      id: cache-pgrx
      uses: actions/cache@v4
      with:
        path: |
          ~/.pgrx/14.*
          ~/.pgrx/14.*_unpack
          ~/.pgrx/config.toml
        # Stable key - only invalidate when pgrx or PG version changes
        key: ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-pg${{ env.PG_VERSION }}-v2
        restore-keys: |
          ${{ runner.os }}-pgrx-pg14-${{ env.PGRX_VERSION }}-

    - name: Initialize pgrx
      if: steps.cache-pgrx.outputs.cache-hit != 'true'
      # Downloads and compiles PostgreSQL 14 (~25 minutes on cold cache)
      run: cargo pgrx init --pg14 download

    # ------------------------------------------------------------------
    # LINTING: Fast checks first (fail fast)
    # ------------------------------------------------------------------
    - name: Check formatting
      run: cargo fmt -- --check

    - name: Run clippy
      run: cargo clippy --features pg14 -- -D warnings

    # ------------------------------------------------------------------
    # PGRX SETUP: Only after linting passes
    # ------------------------------------------------------------------
    - name: Verify pgrx Installation
      run: |
        ls -lh ~/.pgrx/
        # Show size of PG14 installation (handle both 14.* and 14.*_unpack)
        du -sh ~/.pgrx/14.* 2>/dev/null | head -n 1 || echo "No PG14 installation found yet"

    # ------------------------------------------------------------------
    # UNIT TESTING: Non-SPI tests only
    # ------------------------------------------------------------------
    - name: Install cargo-llvm-cov
      uses: taiki-e/install-action@cargo-llvm-cov

    - name: Run unit tests and generate coverage
      # Note: We skip 'cargo pgrx test' because pg_kafka uses PGC_POSTMASTER GUCs
      # which require shared_preload_libraries BEFORE Postgres starts.
      # cargo pgrx test creates the extension AFTER starting Postgres, causing:
      # "FATAL: cannot create PGC_POSTMASTER variables after startup"
      #
      # Instead, we run non-SPI unit tests here (protocol, encoding, helpers).
      # SPI/integration tests are in kafka_test/ E2E suite below.
      run: cargo llvm-cov --lib --features pg14 --lcov --output-path lcov.info
      env:
        # Override RUSTFLAGS to avoid -D warnings (pgrx macros cause false positives)
        RUSTFLAGS: ""

    - name: Upload to Codecov
      uses: codecov/codecov-action@v5
      with:
        files: lcov.info
        token: ${{ secrets.CODECOV_TOKEN }}
        fail_ci_if_error: false  # Don't fail CI if codecov upload fails
      continue-on-error: true  # Continue even if this step fails

    # ------------------------------------------------------------------
    # E2E TESTING: Full system test with external client
    # ------------------------------------------------------------------
    - name: Install Extension
      # Compiles the release build of the pg_kafka extension and copies the .so and .control
      # files into the pgrx-managed Postgres installation directories.
      run: |
        # Debug: List pgrx directory contents
        echo "Contents of ~/.pgrx:"
        ls -la ~/.pgrx/

        # Find pg_config in the pgrx directory structure
        PG_CONFIG=$(find ~/.pgrx -name pg_config -type f -executable 2>/dev/null | grep "14\." | head -n 1)

        if [ -z "$PG_CONFIG" ]; then
          echo "Error: Could not find pg_config for PostgreSQL 14."
          echo "Searching for any pg_config files:"
          find ~/.pgrx -name pg_config -type f
          exit 1
        fi

        echo "Found pg_config at: $PG_CONFIG"

        # Verify it works
        $PG_CONFIG --version

        # Add to PATH and install
        export PATH="$(dirname $PG_CONFIG):$PATH"
        cargo pgrx install --release --pg-config="$PG_CONFIG"

    - name: Initialize Postgres Data Directory
      # pgrx creates the data directory on first start, so we do a quick start/stop
      # to ensure it exists before we modify the config
      run: |
        # Start postgres to create the data directory
        cargo pgrx start pg14 || true
        sleep 2
        # Stop it so we can modify the config
        cargo pgrx stop pg14 || true
        sleep 1

    - name: Configure Postgres for Background Worker
      # CRITICAL STEP:
      # The pg_kafka background worker requires 'BgWorkerStartTime::PostmasterStart'.
      # For this to work, the library must be loaded when Postgres boots up.
      # We append it to shared_preload_libraries in the config file.
      run: |
        # Find the pgrx data directory (should exist now after initialization)
        PG14_DATA_DIR=$(find ~/.pgrx -maxdepth 1 -type d -name "data-14*" | head -n 1)
        if [ -z "$PG14_DATA_DIR" ]; then
          echo "Error: Could not find pgrx-managed Postgres 14 data directory."
          ls -la ~/.pgrx/
          exit 1
        fi
        echo "Using Postgres data directory at: $PG14_DATA_DIR"

        # Check if already configured (idempotency)
        if ! grep -q "shared_preload_libraries.*pg_kafka" "$PG14_DATA_DIR/postgresql.conf"; then
          # Use printf to ensure a preceding newline, preventing config corruption
          printf "\nshared_preload_libraries = 'pg_kafka'\n" >> "$PG14_DATA_DIR/postgresql.conf"
          echo "Configuration updated to preload pg_kafka."
        else
          echo "pg_kafka already configured in shared_preload_libraries."
        fi

    - name: Start Postgres
      # Boots the pgrx-managed Postgres 14 instance.
      # Because we configured shared_preload_libraries above, the background worker will start now.
      run: cargo pgrx start pg14

    - name: Create Extension and Prepare DB
      run: |
        # 1. Find the pgrx data directory and dynamic port
        PG14_DATA_DIR=$(find ~/.pgrx -maxdepth 1 -type d -name "data-14*" | head -n 1)
        if [ -z "$PG14_DATA_DIR" ]; then
          echo "Error: Could not find pgrx-managed Postgres 14 data directory."
          exit 1
        fi
        PG_PORT=$(grep "port =" "$PG14_DATA_DIR/postgresql.conf" | awk '{print $3}')
        echo "PG_PORT=$PG_PORT" >> $GITHUB_ENV

        # 2. Run CREATE EXTENSION
        # pgrx creates a database with the current user's name, not "postgres"
        # In GitHub Actions, the user is "runner"
        DB_USER=$(whoami)
        echo "DB_USER=$DB_USER" >> $GITHUB_ENV
        echo "Using database user: $DB_USER"
        psql -h localhost -p $PG_PORT -U "$DB_USER" -d postgres -c "CREATE DATABASE \"$DB_USER\";" || true
        psql -h localhost -p $PG_PORT -U "$DB_USER" -d "$DB_USER" -c "CREATE EXTENSION IF NOT EXISTS pg_kafka;"

    - name: Check Background Worker Status
      # Debug step: Query pg_stat_activity to see if the worker is actually running
      run: psql -h localhost -p ${{ env.PG_PORT }} -U ${{ env.DB_USER }} -d postgres -c "SELECT pid, backend_type, wait_event_type FROM pg_stat_activity WHERE backend_type = 'pg_kafka_listener';"

    - name: Run E2E Tests
      # Runs the external client application that connects to the running extension
      # via TCP (Kafka protocol) and Postgres (SQL).
      run: |
        cd kafka_test
        cargo run --release
      env:
        # Pass the dynamically discovered port and user to the test runner
        DATABASE_URL: postgresql://${{ env.DB_USER }}@localhost:${{ env.PG_PORT }}/${{ env.DB_USER }}

    # ------------------------------------------------------------------
    # LOAD TESTING: Placeholder
    # ------------------------------------------------------------------
    - name: Load Testing (Placeholder)
      if: always() # Run even if previous tests failed, to gather metrics if possible
      run: |
        echo "TODO: Implement Load Testing"
        # Example: Run k6 or bespoke load generator
        # k6 run load-test.js
        # cargo run --release --bin load_generator

    # ------------------------------------------------------------------
    # DEBUGGING: Print logs on failure
    # ------------------------------------------------------------------
    - name: Print Postgres Logs
      if: failure()
      run: |
        find ~/.pgrx -name "postgresql-*.log" -exec echo "=== {} ===" \; -exec cat {} \;

    # ------------------------------------------------------------------
    # TEARDOWN: Cleanup
    # ------------------------------------------------------------------
    - name: Stop pgrx
      if: always()
      # Ensures the background Postgres process is killed, freeing resources.
      run: cargo pgrx stop pg14